// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package public_graph_generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	public_graph_model "brume.dev/internal/router/public-gql/graph/model"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CloudAccount() CloudAccountResolver
	Mutation() MutationResolver
	Organization() OrganizationResolver
	Project() ProjectResolver
	Query() QueryResolver
	Source() SourceResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	BaseService struct {
		Builder func(childComplexity int) int
		Runner  func(childComplexity int) int
		Source  func(childComplexity int) int
	}

	Builder struct {
		Data    func(childComplexity int) int
		ID      func(childComplexity int) int
		Link    func(childComplexity int) int
		Schema  func(childComplexity int) int
		Type    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	CloudAccount struct {
		CloudProvider func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Stacks        func(childComplexity int) int
		Status        func(childComplexity int) int
	}

	CreateCloudAccountResponse struct {
		ID func(childComplexity int) int
	}

	DeployStackResponse struct {
		ID func(childComplexity int) int
	}

	Mutation struct {
		CreateCloudAccount func(childComplexity int, input public_graph_model.CreateCloudAccountInput) int
		DeployStack        func(childComplexity int, input public_graph_model.DeployStackInput) int
	}

	Organization struct {
		CloudAccounts func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	Project struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		IsDirty     func(childComplexity int) int
		Name        func(childComplexity int) int
		Services    func(childComplexity int) int
	}

	Query struct {
		GetAWSCloudFormationURL func(childComplexity int) int
		GetCloudAccountByID     func(childComplexity int, id string) int
		GetProjectByID          func(childComplexity int, id string) int
		GetStack                func(childComplexity int, id string) int
		GetStackTemplates       func(childComplexity int) int
		GetStacks               func(childComplexity int) int
		Me                      func(childComplexity int) int
	}

	Runner struct {
		Data    func(childComplexity int) int
		ID      func(childComplexity int) int
		Link    func(childComplexity int) int
		Schema  func(childComplexity int) int
		Type    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	Service struct {
		Draft func(childComplexity int) int
		ID    func(childComplexity int) int
		Live  func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	Source struct {
		Data func(childComplexity int) int
		ID   func(childComplexity int) int
		Type func(childComplexity int) int
	}

	Stack struct {
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Status     func(childComplexity int) int
		TemplateID func(childComplexity int) int
	}

	StackTemplate struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	User struct {
		Avatar       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Organization func(childComplexity int) int
		Projects     func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "BaseService.builder":
		if e.complexity.BaseService.Builder == nil {
			break
		}

		return e.complexity.BaseService.Builder(childComplexity), true

	case "BaseService.runner":
		if e.complexity.BaseService.Runner == nil {
			break
		}

		return e.complexity.BaseService.Runner(childComplexity), true

	case "BaseService.source":
		if e.complexity.BaseService.Source == nil {
			break
		}

		return e.complexity.BaseService.Source(childComplexity), true

	case "Builder.data":
		if e.complexity.Builder.Data == nil {
			break
		}

		return e.complexity.Builder.Data(childComplexity), true

	case "Builder.id":
		if e.complexity.Builder.ID == nil {
			break
		}

		return e.complexity.Builder.ID(childComplexity), true

	case "Builder.link":
		if e.complexity.Builder.Link == nil {
			break
		}

		return e.complexity.Builder.Link(childComplexity), true

	case "Builder.schema":
		if e.complexity.Builder.Schema == nil {
			break
		}

		return e.complexity.Builder.Schema(childComplexity), true

	case "Builder.type":
		if e.complexity.Builder.Type == nil {
			break
		}

		return e.complexity.Builder.Type(childComplexity), true

	case "Builder.version":
		if e.complexity.Builder.Version == nil {
			break
		}

		return e.complexity.Builder.Version(childComplexity), true

	case "CloudAccount.cloudProvider":
		if e.complexity.CloudAccount.CloudProvider == nil {
			break
		}

		return e.complexity.CloudAccount.CloudProvider(childComplexity), true

	case "CloudAccount.id":
		if e.complexity.CloudAccount.ID == nil {
			break
		}

		return e.complexity.CloudAccount.ID(childComplexity), true

	case "CloudAccount.name":
		if e.complexity.CloudAccount.Name == nil {
			break
		}

		return e.complexity.CloudAccount.Name(childComplexity), true

	case "CloudAccount.stacks":
		if e.complexity.CloudAccount.Stacks == nil {
			break
		}

		return e.complexity.CloudAccount.Stacks(childComplexity), true

	case "CloudAccount.status":
		if e.complexity.CloudAccount.Status == nil {
			break
		}

		return e.complexity.CloudAccount.Status(childComplexity), true

	case "CreateCloudAccountResponse.id":
		if e.complexity.CreateCloudAccountResponse.ID == nil {
			break
		}

		return e.complexity.CreateCloudAccountResponse.ID(childComplexity), true

	case "DeployStackResponse.id":
		if e.complexity.DeployStackResponse.ID == nil {
			break
		}

		return e.complexity.DeployStackResponse.ID(childComplexity), true

	case "Mutation.createCloudAccount":
		if e.complexity.Mutation.CreateCloudAccount == nil {
			break
		}

		args, err := ec.field_Mutation_createCloudAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCloudAccount(childComplexity, args["input"].(public_graph_model.CreateCloudAccountInput)), true

	case "Mutation.deployStack":
		if e.complexity.Mutation.DeployStack == nil {
			break
		}

		args, err := ec.field_Mutation_deployStack_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeployStack(childComplexity, args["input"].(public_graph_model.DeployStackInput)), true

	case "Organization.cloudAccounts":
		if e.complexity.Organization.CloudAccounts == nil {
			break
		}

		return e.complexity.Organization.CloudAccounts(childComplexity), true

	case "Organization.id":
		if e.complexity.Organization.ID == nil {
			break
		}

		return e.complexity.Organization.ID(childComplexity), true

	case "Organization.name":
		if e.complexity.Organization.Name == nil {
			break
		}

		return e.complexity.Organization.Name(childComplexity), true

	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.isDirty":
		if e.complexity.Project.IsDirty == nil {
			break
		}

		return e.complexity.Project.IsDirty(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.services":
		if e.complexity.Project.Services == nil {
			break
		}

		return e.complexity.Project.Services(childComplexity), true

	case "Query.getAWSCloudFormationURL":
		if e.complexity.Query.GetAWSCloudFormationURL == nil {
			break
		}

		return e.complexity.Query.GetAWSCloudFormationURL(childComplexity), true

	case "Query.getCloudAccountById":
		if e.complexity.Query.GetCloudAccountByID == nil {
			break
		}

		args, err := ec.field_Query_getCloudAccountById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetCloudAccountByID(childComplexity, args["id"].(string)), true

	case "Query.getProjectById":
		if e.complexity.Query.GetProjectByID == nil {
			break
		}

		args, err := ec.field_Query_getProjectById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProjectByID(childComplexity, args["id"].(string)), true

	case "Query.getStack":
		if e.complexity.Query.GetStack == nil {
			break
		}

		args, err := ec.field_Query_getStack_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStack(childComplexity, args["id"].(string)), true

	case "Query.getStackTemplates":
		if e.complexity.Query.GetStackTemplates == nil {
			break
		}

		return e.complexity.Query.GetStackTemplates(childComplexity), true

	case "Query.getStacks":
		if e.complexity.Query.GetStacks == nil {
			break
		}

		return e.complexity.Query.GetStacks(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Runner.data":
		if e.complexity.Runner.Data == nil {
			break
		}

		return e.complexity.Runner.Data(childComplexity), true

	case "Runner.id":
		if e.complexity.Runner.ID == nil {
			break
		}

		return e.complexity.Runner.ID(childComplexity), true

	case "Runner.link":
		if e.complexity.Runner.Link == nil {
			break
		}

		return e.complexity.Runner.Link(childComplexity), true

	case "Runner.schema":
		if e.complexity.Runner.Schema == nil {
			break
		}

		return e.complexity.Runner.Schema(childComplexity), true

	case "Runner.type":
		if e.complexity.Runner.Type == nil {
			break
		}

		return e.complexity.Runner.Type(childComplexity), true

	case "Runner.version":
		if e.complexity.Runner.Version == nil {
			break
		}

		return e.complexity.Runner.Version(childComplexity), true

	case "Service.draft":
		if e.complexity.Service.Draft == nil {
			break
		}

		return e.complexity.Service.Draft(childComplexity), true

	case "Service.id":
		if e.complexity.Service.ID == nil {
			break
		}

		return e.complexity.Service.ID(childComplexity), true

	case "Service.live":
		if e.complexity.Service.Live == nil {
			break
		}

		return e.complexity.Service.Live(childComplexity), true

	case "Service.name":
		if e.complexity.Service.Name == nil {
			break
		}

		return e.complexity.Service.Name(childComplexity), true

	case "Source.data":
		if e.complexity.Source.Data == nil {
			break
		}

		return e.complexity.Source.Data(childComplexity), true

	case "Source.id":
		if e.complexity.Source.ID == nil {
			break
		}

		return e.complexity.Source.ID(childComplexity), true

	case "Source.type":
		if e.complexity.Source.Type == nil {
			break
		}

		return e.complexity.Source.Type(childComplexity), true

	case "Stack.id":
		if e.complexity.Stack.ID == nil {
			break
		}

		return e.complexity.Stack.ID(childComplexity), true

	case "Stack.name":
		if e.complexity.Stack.Name == nil {
			break
		}

		return e.complexity.Stack.Name(childComplexity), true

	case "Stack.status":
		if e.complexity.Stack.Status == nil {
			break
		}

		return e.complexity.Stack.Status(childComplexity), true

	case "Stack.template_id":
		if e.complexity.Stack.TemplateID == nil {
			break
		}

		return e.complexity.Stack.TemplateID(childComplexity), true

	case "StackTemplate.id":
		if e.complexity.StackTemplate.ID == nil {
			break
		}

		return e.complexity.StackTemplate.ID(childComplexity), true

	case "StackTemplate.name":
		if e.complexity.StackTemplate.Name == nil {
			break
		}

		return e.complexity.StackTemplate.Name(childComplexity), true

	case "User.avatar":
		if e.complexity.User.Avatar == nil {
			break
		}

		return e.complexity.User.Avatar(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.organization":
		if e.complexity.User.Organization == nil {
			break
		}

		return e.complexity.User.Organization(childComplexity), true

	case "User.projects":
		if e.complexity.User.Projects == nil {
			break
		}

		return e.complexity.User.Projects(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateCloudAccountInput,
		ec.unmarshalInputDeployStackInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../public.graphql", Input: `# public brume GQL schema
scalar Any

type User {
	id: String!
	name: String!
	avatar: String!
	projects: [Project!]!
	organization: Organization!
}

type Organization {
	id: String!
	name: String!

	cloudAccounts: [CloudAccount!]!
}

enum CloudProvider {
	AWS
	Azure
	GCP
}

enum CloudStatus {
	Pending
	Connected
	Disconnected
	Error
}

enum StackStatus {
	Pending
	Deploying
	Deployed
	Failed
}

type Stack {
	template_id: String!
	id: String!
	name: String!
	status: StackStatus!
}

type StackTemplate {
	id: String!
	name: String!
}

type CloudAccount {
	id: String!
	cloudProvider: CloudProvider!
	status: CloudStatus!
	name: String!

	stacks: [Stack!]!
}

type Project {
	id: String!
	name: String!
	description: String!
	isDirty: Boolean!
	services: [Service!]!
}

type Source {
	id: String!
	type: String!
	data: Any!
}

type Runner {
	id: String!
	type: String!
	link: String!
	version: String!

	schema: Any!
	data: Any!
}

type Builder {
	id: String!
	type: String!
	link: String!
	version: String!

	schema: Any!
	data: Any!
}

type BaseService {
	source: Source!
	runner: Runner!
	builder: Builder!
}

type Service {
	id: String!
	name: String!

	live: BaseService!
	draft: BaseService
}

type Query {
	# get the current user
	me: User!

	getProjectById(id: String!): Project!
	getAWSCloudFormationURL: String!
	getCloudAccountById(id: String!): CloudAccount!
	getStackTemplates: [StackTemplate!]!
	getStacks: [Stack!]!
	getStack(id: String!): Stack!
}

input CreateCloudAccountInput {
	name: String!
	accountId: String!
	cloudProvider: CloudProvider!
}

type CreateCloudAccountResponse {
	id: String!
}

input DeployStackInput {
	name: String!
	templateId: String!
	cloudAccountId: String!
}

type DeployStackResponse {
	id: String!
}

type Mutation {
	createCloudAccount(
		input: CreateCloudAccountInput!
	): CreateCloudAccountResponse!

	deployStack(input: DeployStackInput!): DeployStackResponse!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
