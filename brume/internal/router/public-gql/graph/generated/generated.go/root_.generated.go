// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package public_graph_generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	public_graph_model "brume.dev/internal/router/public-gql/graph/model"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Log() LogResolver
	Mutation() MutationResolver
	Project() ProjectResolver
	Query() QueryResolver
	Service() ServiceResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Builder struct {
		Data func(childComplexity int) int
		Type func(childComplexity int) int
	}

	BuilderData struct {
		Image    func(childComplexity int) int
		Registry func(childComplexity int) int
		Tag      func(childComplexity int) int
	}

	Log struct {
		ID        func(childComplexity int) int
		Level     func(childComplexity int) int
		Message   func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	Mutation struct {
		AddServiceToProject func(childComplexity int, projectID string, input public_graph_model.CreateServiceInput) int
		CreateProject       func(childComplexity int, name string, description *string) int
		UpdateBuilder       func(childComplexity int, serviceID string, data public_graph_model.BuilderDataInput) int
		UpdateRunner        func(childComplexity int, serviceID string, data public_graph_model.RunnerDataInput) int
	}

	Project struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Services    func(childComplexity int) int
	}

	Query struct {
		GetProjectByID func(childComplexity int, id string) int
		Me             func(childComplexity int) int
		ServiceLogs    func(childComplexity int, serviceID string) int
	}

	RessourceConstraints struct {
		Limit   func(childComplexity int) int
		Request func(childComplexity int) int
	}

	Runner struct {
		Data func(childComplexity int) int
		Type func(childComplexity int) int
	}

	RunnerData struct {
		CPU            func(childComplexity int) int
		Command        func(childComplexity int) int
		HealthCheckURL func(childComplexity int) int
		Memory         func(childComplexity int) int
		Port           func(childComplexity int) int
		PrivateDomain  func(childComplexity int) int
		PublicDomain   func(childComplexity int) int
	}

	Service struct {
		Builder func(childComplexity int) int
		ID      func(childComplexity int) int
		Name    func(childComplexity int) int
		Runner  func(childComplexity int) int
	}

	Subscription struct {
		ServiceLogs func(childComplexity int, serviceID string) int
	}

	User struct {
		Avatar   func(childComplexity int) int
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Projects func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Builder.data":
		if e.complexity.Builder.Data == nil {
			break
		}

		return e.complexity.Builder.Data(childComplexity), true

	case "Builder.type":
		if e.complexity.Builder.Type == nil {
			break
		}

		return e.complexity.Builder.Type(childComplexity), true

	case "BuilderData.image":
		if e.complexity.BuilderData.Image == nil {
			break
		}

		return e.complexity.BuilderData.Image(childComplexity), true

	case "BuilderData.registry":
		if e.complexity.BuilderData.Registry == nil {
			break
		}

		return e.complexity.BuilderData.Registry(childComplexity), true

	case "BuilderData.tag":
		if e.complexity.BuilderData.Tag == nil {
			break
		}

		return e.complexity.BuilderData.Tag(childComplexity), true

	case "Log.id":
		if e.complexity.Log.ID == nil {
			break
		}

		return e.complexity.Log.ID(childComplexity), true

	case "Log.level":
		if e.complexity.Log.Level == nil {
			break
		}

		return e.complexity.Log.Level(childComplexity), true

	case "Log.message":
		if e.complexity.Log.Message == nil {
			break
		}

		return e.complexity.Log.Message(childComplexity), true

	case "Log.timestamp":
		if e.complexity.Log.Timestamp == nil {
			break
		}

		return e.complexity.Log.Timestamp(childComplexity), true

	case "Mutation.addServiceToProject":
		if e.complexity.Mutation.AddServiceToProject == nil {
			break
		}

		args, err := ec.field_Mutation_addServiceToProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddServiceToProject(childComplexity, args["projectId"].(string), args["input"].(public_graph_model.CreateServiceInput)), true

	case "Mutation.createProject":
		if e.complexity.Mutation.CreateProject == nil {
			break
		}

		args, err := ec.field_Mutation_createProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProject(childComplexity, args["name"].(string), args["description"].(*string)), true

	case "Mutation.updateBuilder":
		if e.complexity.Mutation.UpdateBuilder == nil {
			break
		}

		args, err := ec.field_Mutation_updateBuilder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBuilder(childComplexity, args["serviceId"].(string), args["data"].(public_graph_model.BuilderDataInput)), true

	case "Mutation.updateRunner":
		if e.complexity.Mutation.UpdateRunner == nil {
			break
		}

		args, err := ec.field_Mutation_updateRunner_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateRunner(childComplexity, args["serviceId"].(string), args["data"].(public_graph_model.RunnerDataInput)), true

	case "Project.description":
		if e.complexity.Project.Description == nil {
			break
		}

		return e.complexity.Project.Description(childComplexity), true

	case "Project.id":
		if e.complexity.Project.ID == nil {
			break
		}

		return e.complexity.Project.ID(childComplexity), true

	case "Project.name":
		if e.complexity.Project.Name == nil {
			break
		}

		return e.complexity.Project.Name(childComplexity), true

	case "Project.services":
		if e.complexity.Project.Services == nil {
			break
		}

		return e.complexity.Project.Services(childComplexity), true

	case "Query.getProjectById":
		if e.complexity.Query.GetProjectByID == nil {
			break
		}

		args, err := ec.field_Query_getProjectById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProjectByID(childComplexity, args["id"].(string)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.serviceLogs":
		if e.complexity.Query.ServiceLogs == nil {
			break
		}

		args, err := ec.field_Query_serviceLogs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServiceLogs(childComplexity, args["serviceId"].(string)), true

	case "RessourceConstraints.limit":
		if e.complexity.RessourceConstraints.Limit == nil {
			break
		}

		return e.complexity.RessourceConstraints.Limit(childComplexity), true

	case "RessourceConstraints.request":
		if e.complexity.RessourceConstraints.Request == nil {
			break
		}

		return e.complexity.RessourceConstraints.Request(childComplexity), true

	case "Runner.data":
		if e.complexity.Runner.Data == nil {
			break
		}

		return e.complexity.Runner.Data(childComplexity), true

	case "Runner.type":
		if e.complexity.Runner.Type == nil {
			break
		}

		return e.complexity.Runner.Type(childComplexity), true

	case "RunnerData.cpu":
		if e.complexity.RunnerData.CPU == nil {
			break
		}

		return e.complexity.RunnerData.CPU(childComplexity), true

	case "RunnerData.command":
		if e.complexity.RunnerData.Command == nil {
			break
		}

		return e.complexity.RunnerData.Command(childComplexity), true

	case "RunnerData.healthCheckURL":
		if e.complexity.RunnerData.HealthCheckURL == nil {
			break
		}

		return e.complexity.RunnerData.HealthCheckURL(childComplexity), true

	case "RunnerData.memory":
		if e.complexity.RunnerData.Memory == nil {
			break
		}

		return e.complexity.RunnerData.Memory(childComplexity), true

	case "RunnerData.port":
		if e.complexity.RunnerData.Port == nil {
			break
		}

		return e.complexity.RunnerData.Port(childComplexity), true

	case "RunnerData.privateDomain":
		if e.complexity.RunnerData.PrivateDomain == nil {
			break
		}

		return e.complexity.RunnerData.PrivateDomain(childComplexity), true

	case "RunnerData.publicDomain":
		if e.complexity.RunnerData.PublicDomain == nil {
			break
		}

		return e.complexity.RunnerData.PublicDomain(childComplexity), true

	case "Service.builder":
		if e.complexity.Service.Builder == nil {
			break
		}

		return e.complexity.Service.Builder(childComplexity), true

	case "Service.id":
		if e.complexity.Service.ID == nil {
			break
		}

		return e.complexity.Service.ID(childComplexity), true

	case "Service.name":
		if e.complexity.Service.Name == nil {
			break
		}

		return e.complexity.Service.Name(childComplexity), true

	case "Service.runner":
		if e.complexity.Service.Runner == nil {
			break
		}

		return e.complexity.Service.Runner(childComplexity), true

	case "Subscription.serviceLogs":
		if e.complexity.Subscription.ServiceLogs == nil {
			break
		}

		args, err := ec.field_Subscription_serviceLogs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.ServiceLogs(childComplexity, args["serviceId"].(string)), true

	case "User.avatar":
		if e.complexity.User.Avatar == nil {
			break
		}

		return e.complexity.User.Avatar(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.projects":
		if e.complexity.User.Projects == nil {
			break
		}

		return e.complexity.User.Projects(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBuilderDataInput,
		ec.unmarshalInputCreateServiceInput,
		ec.unmarshalInputRessourceConstraintsInput,
		ec.unmarshalInputRunnerDataInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../public.graphql", Input: `# public brume GQL schema
type User {
  id: String!
  name: String!
  avatar: String!
  projects: [Project!]!
}

type Project {
  id: String!
  name: String!
  description: String!
  services: [Service!]!
}

type Builder {
  type: String!
  data: BuilderData!
}

type BuilderData {
  image: String!
  registry: String!
  tag: String!
}

input BuilderDataInput {
  image: String!
  registry: String!
  tag: String!
}

type Runner {
  type: String!
  data: RunnerData!
}

type RessourceConstraints {
  request: Float!
  limit: Float!
}

input RessourceConstraintsInput {
  request: Float!
  limit: Float!
}

type RunnerData {
  command: String!
  healthCheckURL: String!
  memory: RessourceConstraints!
  cpu: RessourceConstraints!
  port: Int!
  publicDomain: String!
  privateDomain: String!
}

input RunnerDataInput {
  healthCheckURL: String!
  memory: RessourceConstraintsInput!
  cpu: RessourceConstraintsInput!
  port: Int!
  publicDomain: String!
  privateDomain: String!
}

type Service {
  id: String!
  name: String!
  builder: Builder!
  runner: Runner!
}

type Log {
  id: String!
  message: String!
  level: String!
  timestamp: String!
}

input CreateServiceInput {
  name: String!
  image: String!
}

type Query {
  me: User!
  getProjectById(id: String!): Project!
  serviceLogs(serviceId: String!): [Log]!
}

type Mutation {
  createProject(name: String!, description: String): Project!
  addServiceToProject(projectId: String!, input: CreateServiceInput!): Service!
  updateBuilder(serviceId: String!, data: BuilderDataInput!): Builder!
  updateRunner(serviceId: String!, data: RunnerDataInput!): Runner!
}

type Subscription {
  serviceLogs(serviceId: String!): [Log]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
